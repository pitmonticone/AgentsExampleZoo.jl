<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Daisyworld · Agents.jl Example Zoo</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl Example Zoo logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl Example Zoo</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../growing_bacteria/">Bacterial Growth</a></li><li><a class="tocitem" href="../battle/">Battle Royale</a></li><li><a class="tocitem" href="../social_distancing/">Continuous space social distancing</a></li><li><a class="tocitem" href="../game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li class="is-active"><a class="tocitem" href>Daisyworld</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-Daisyworld"><span>Overview of Daisyworld</span></a></li><li><a class="tocitem" href="#Defining-the-agent-types"><span>Defining the agent types</span></a></li><li><a class="tocitem" href="#World-heating"><span>World heating</span></a></li><li><a class="tocitem" href="#Daisy-dynamics"><span>Daisy dynamics</span></a></li><li><a class="tocitem" href="#Initialising-Daisyworld"><span>Initialising Daisyworld</span></a></li><li><a class="tocitem" href="#Visualizing-and-animating"><span>Visualizing &amp; animating</span></a></li><li><a class="tocitem" href="#Time-dependent-dynamics"><span>Time dependent dynamics</span></a></li><li><a class="tocitem" href="#Interactive-scientific-research"><span>Interactive scientific research</span></a></li></ul></li><li><a class="tocitem" href="../forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../fractal_growth/">Fractal Growth</a></li><li><a class="tocitem" href="../hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../maze/">Maze Solver</a></li><li><a class="tocitem" href="../runners/">Mountain Runners</a></li><li><a class="tocitem" href="../opinion_spread/">Opinion spread</a></li><li><a class="tocitem" href="../predator_prey_fast/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../sugarscape/">Sugarscape</a></li><li><a class="tocitem" href="../wealth_distribution/">Wealth distribution model</a></li><li><a class="tocitem" href="../wright-fisher/">Wright-Fisher model of evolution</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Daisyworld</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Daisyworld</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/AgentsExampleZoo.jl/blob/master/docs/examples/daisyworld.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Daisyworld"><a class="docs-heading-anchor" href="#Daisyworld">Daisyworld</a><a id="Daisyworld-1"></a><a class="docs-heading-anchor-permalink" href="#Daisyworld" title="Permalink"></a></h1><video width="auto" controls autoplay loop>
<source src="../daisyworld.mp4" type="video/mp4">
</video><p>Study this example to learn about</p><ul><li>Simple agent properties with complex model interactions</li><li>Diffusion of a quantity in a <code>GridSpace</code></li><li>Including a &quot;surface property&quot; in the model</li><li>counting time in the model and having time-dependent dynamics</li><li>performing interactive scientific research</li></ul><h2 id="Overview-of-Daisyworld"><a class="docs-heading-anchor" href="#Overview-of-Daisyworld">Overview of Daisyworld</a><a id="Overview-of-Daisyworld-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Daisyworld" title="Permalink"></a></h2><p>This model explores the <a href="https://en.wikipedia.org/wiki/Gaia_hypothesis">Gaia hypothesis</a>, which considers the Earth as a single, self-regulating system including both living and non-living parts.</p><p>Daisyworld is filled with black and white daisies. Their albedo&#39;s differ, with black daisies absorbing light and heat, warming the area around them; white daisies doing the opposite. Daisies can only reproduce within a certain temperature range, meaning too much (or too little) heat coming from the sun and/or surrounds will ultimately halt daisy propagation.</p><p>When the climate is too cold it is necessary for the black daisies to propagate in order to raise the temperature, and vice versa – when the climate is too warm, it is necessary for more white daisies to be produced in order to cool the temperature. The interplay of the living and non living aspects of this world manages to find an equilibrium over a wide range of parameter settings, although with enough external forcing, the daisies will not be able to regulate the temperature of the planet and eventually go extinct.</p><h2 id="Defining-the-agent-types"><a class="docs-heading-anchor" href="#Defining-the-agent-types">Defining the agent types</a><a id="Defining-the-agent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-agent-types" title="Permalink"></a></h2><p><code>Daisy</code> has three values (other than the required <code>id</code> and <code>pos</code> for an agent that lives on a <a href="examples/@ref"><code>GridSpace</code></a>. Each daisy has an <code>age</code>, confined later by a maximum age set by the user, a <code>breed</code> (either <code>:black</code> or <code>:white</code>) and an associated <code>albedo</code> value, again set by the user. <code>Land</code> represents the surface. We could make <code>Land</code> also have an albedo field, but in this world, the entire surface has the same albedo and thus we make it a model parameter.</p><p>Notice that the <code>Land</code> does not necessarily have to be an agent, and one could represent surface temperature via a matrix (parameter of the model). This is done in an older version, see file <code>examples/daisyworld_matrix.jl</code>. The old version has a slight performance advantage. However, the advantage of making the surface composed of agents is that visualization is simple and one can use the interactive application to also visualize surface temperature. It is also available from the <code>Models</code> module as <a href="examples/@ref"><code>Models.daisyworld</code></a>.</p><pre><code class="language-julia hljs">using Agents
using Statistics: mean

mutable struct Daisy &lt;: AbstractAgent
    id::Int
    pos::Dims{2}
    breed::Symbol
    age::Int
    albedo::Float64 # 0-1 fraction
end

const DaisyWorld = ABM{&lt;:GridSpace, Daisy};</code></pre><h2 id="World-heating"><a class="docs-heading-anchor" href="#World-heating">World heating</a><a id="World-heating-1"></a><a class="docs-heading-anchor-permalink" href="#World-heating" title="Permalink"></a></h2><p>The surface temperature of the world is heated by its sun, but daisies growing upon it absorb or reflect the starlight – altering the local temperature.</p><pre><code class="language-julia hljs">function update_surface_temperature!(pos, model::DaisyWorld)
    ids = ids_in_position(pos, model)
    absorbed_luminosity = if isempty(ids) # no daisy
        # Set luminosity via surface albedo
        (1 - model.surface_albedo) * model.solar_luminosity
    else
        # Set luminosity via daisy albedo
        (1 - model[ids[1]].albedo) * model.solar_luminosity
    end
    # We expect local heating to be 80 ᵒC for an absorbed luminosity of 1,
    # approximately 30 for 0.5 and approximately -273 for 0.01.
    local_heating = absorbed_luminosity &gt; 0 ? 72 * log(absorbed_luminosity) + 80 : 80
    # Surface temperature is the average of the current temperature and local heating.
    model.temperature[pos...] = (model.temperature[pos...] + local_heating) / 2
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">update_surface_temperature! (generic function with 1 method)</code></pre><p>In addition, temperature diffuses over time</p><pre><code class="language-julia hljs">function diffuse_temperature!(pos, model::DaisyWorld)
    ratio = get(model.properties, :ratio, 0.5) # diffusion ratio
    npos = nearby_positions(pos, model)
    model.temperature[pos...] =
        (1 - ratio) * model.temperature[pos...] +
        # Each neighbor is giving up 1/8 of the diffused
        # amount to each of *its* neighbors
        sum(model.temperature[p...] for p in npos) * 0.125 * ratio
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">diffuse_temperature! (generic function with 1 method)</code></pre><h2 id="Daisy-dynamics"><a class="docs-heading-anchor" href="#Daisy-dynamics">Daisy dynamics</a><a id="Daisy-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Daisy-dynamics" title="Permalink"></a></h2><p>The final piece of the puzzle is the life-cycle of each daisy. This method defines an optimal temperature for growth. If the temperature gets too hot or too cold, daisies will not wish to propagate. So long as the temperature is favorable, daisies compete for land and attempt to spawn a new plant of their <code>breed</code> in locations close to them.</p><pre><code class="language-julia hljs">function propagate!(pos, model::DaisyWorld)
    ids = ids_in_position(pos, model)
    if !isempty(ids)
        daisy = model[ids[1]]
        temperature = model.temperature[pos...]
        # Set optimum growth rate to 22.5 ᵒC, with bounds of [5, 40]
        seed_threshold = (0.1457 * temperature - 0.0032 * temperature^2) - 0.6443
        if rand(model.rng) &lt; seed_threshold
            # Collect all adjacent position that have no daisies
            empty_neighbors = Tuple{Int,Int}[]
            neighbors = nearby_positions(pos, model)
            for n in neighbors
                if isempty(ids_in_position(n, model))
                    push!(empty_neighbors, n)
                end
            end
            if !isempty(empty_neighbors)
                # Seed a new daisy in one of those position
                seeding_place = rand(model.rng, empty_neighbors)
                add_agent!(seeding_place, model, daisy.breed, 0, daisy.albedo)
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">propagate! (generic function with 1 method)</code></pre><p>And if the daisies cross an age threshold, they die out. Death is controlled by the <code>agent_step</code> function</p><pre><code class="language-julia hljs">function agent_step!(agent::Daisy, model::DaisyWorld)
    agent.age += 1
    agent.age &gt;= model.max_age &amp;&amp; kill_agent!(agent, model)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">agent_step! (generic function with 1 method)</code></pre><p>The model step function advances Daisyworld&#39;s dynamics:</p><pre><code class="language-julia hljs">function model_step!(model)
    for p in positions(model)
        update_surface_temperature!(p, model)
        diffuse_temperature!(p, model)
        propagate!(p, model)
    end
    model.tick += 1
    solar_activity!(model)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model_step! (generic function with 1 method)</code></pre><p>Notice that <code>solar_activity!</code> changes the incoming solar radiation over time, if the given &quot;scenario&quot; (a model parameter) is <code>:ramp</code>. The parameter <code>tick</code> of the model keeps track of time.</p><pre><code class="language-julia hljs">function solar_activity!(model::DaisyWorld)
    if model.scenario == :ramp
        if model.tick &gt; 200 &amp;&amp; model.tick &lt;= 400
            model.solar_luminosity += model.solar_change
        end
        if model.tick &gt; 500 &amp;&amp; model.tick &lt;= 750
            model.solar_luminosity -= model.solar_change / 2
        end
    elseif model.scenario == :change
        model.solar_luminosity += model.solar_change
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solar_activity! (generic function with 1 method)</code></pre><h2 id="Initialising-Daisyworld"><a class="docs-heading-anchor" href="#Initialising-Daisyworld">Initialising Daisyworld</a><a id="Initialising-Daisyworld-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-Daisyworld" title="Permalink"></a></h2><p>Here, we construct a function to initialize a Daisyworld. We use <a href="examples/@ref"><code>fill_space!</code></a> to fill the space with <code>Land</code> instances. Then, we need to know how many daisies of each type to seed the planet with and what their albedo&#39;s are. We also want a value for surface albedo, as well as solar intensity (and we also choose between constant or time-dependent intensity with <code>scenario</code>).</p><pre><code class="language- hljs">import StatsBase
import DrWatson: @dict
using Random

function daisyworld(;
    griddims = (30, 30),
    max_age = 25,
    init_white = 0.2, # % cover of the world surface of white breed
    init_black = 0.2, # % cover of the world surface of black breed
    albedo_white = 0.75,
    albedo_black = 0.25,
    surface_albedo = 0.4,
    solar_change = 0.005,
    solar_luminosity = 1.0, # initial luminosity
    scenario = :default,
    seed = 165,
)

    rng = MersenneTwister(seed)
    space = GridSpace(griddims)
    properties = @dict max_age surface_albedo solar_luminosity solar_change scenario
    properties[:tick] = 0
    properties[:temperature] = zeros(griddims)

    model = ABM(Daisy, space; properties, rng)

    # Populate with daisies: each position has only one daisy (black or white)
    grid = collect(positions(model))
    num_positions = prod(griddims)
    white_positions =
        StatsBase.sample(grid, Int(init_white * num_positions); replace = false)
    for wp in white_positions
        wd = Daisy(nextid(model), wp, :white, rand(model.rng, 0:max_age), albedo_white)
        add_agent_pos!(wd, model)
    end
    allowed = setdiff(grid, white_positions)
    black_positions =
        StatsBase.sample(allowed, Int(init_black * num_positions); replace = false)
    for bp in black_positions
        wd = Daisy(nextid(model), bp, :black, rand(model.rng, 0:max_age), albedo_black)
        add_agent_pos!(wd, model)
    end

    # Adjust temperature to initial daisy distribution
    for p in positions(model)
        update_surface_temperature!(p, model)
    end

    return model
end</code></pre><h2 id="Visualizing-and-animating"><a class="docs-heading-anchor" href="#Visualizing-and-animating">Visualizing &amp; animating</a><a id="Visualizing-and-animating-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-and-animating" title="Permalink"></a></h2><p>Lets run the model with constant solar isolation and visualize the result</p><pre><code class="language- hljs">using InteractiveDynamics
using CairoMakie
CairoMakie.activate!() # hide

model = daisyworld()</code></pre><p>To visualize we need to define the necessary functions for <a href="examples/@ref"><code>abm_plot</code></a>. We will also utilize its ability to plot an underlying heatmap, which will be the model surface temperature, while daisies will be plotted in black and white as per their breed. Notice that we will explicitly provide a <code>colorrange</code> to the heatmap keywords, otherwise the colormap will be continuously and automatically updated to match the underlying temperature values while we are animating the time evolution.</p><pre><code class="language- hljs">daisycolor(a::Daisy) = a.breed

plotkwargs = (
    ac=daisycolor, as = 12, am = &#39;♠&#39;,
    heatarray = :temperature,
    heatkwargs = (colorrange = (-20, 60),),
)
fig, _ = abm_plot(model; plotkwargs...)
fig</code></pre><p>And after a couple of steps</p><pre><code class="language- hljs">Agents.step!(model, agent_step!, model_step!, 5)
fig, _ = abm_plot(model; heatarray = model.temperature, plotkwargs...)
fig</code></pre><p>Let&#39;s do some animation now</p><pre><code class="language- hljs">model = daisyworld()
abm_video(
    &quot;daisyworld.mp4&quot;,
    model,
    agent_step!,
    model_step!;
    title = &quot;Daisy World&quot;,
    plotkwargs...,
)</code></pre><video width="auto" controls autoplay loop>
<source src="../daisyworld.mp4" type="video/mp4">
</video><p>Running this animation for longer hints that this world achieves quasi-equilibrium for some input parameters, where one <code>breed</code> does not totally dominate the other. Of course we can check this easily through data collection. Notice that here we have to define a function <code>breed</code> that returns the daisy&#39;s <code>breed</code> field. We cannot use just <code>:breed</code> to automatically find it, because in this mixed agent model, the <code>Land</code> doesn&#39;t have any <code>breed</code>.</p><pre><code class="language- hljs">black(a) = a.breed == :black
white(a) = a.breed == :white
adata = [(black, count), (white, count)]

model = daisyworld(; solar_luminosity = 1.0)

agent_df, model_df = run!(model, agent_step!, model_step!, 1000; adata)
figure = Figure(resolution = (600, 400))
ax = figure[1, 1] = Axis(figure, xlabel = &quot;tick&quot;, ylabel = &quot;daisy count&quot;)
blackl = lines!(ax, agent_df[!, :step], agent_df[!, :count_black], color = :red)
whitel = lines!(ax, agent_df[!, :step], agent_df[!, :count_white], color = :blue)
figure[1, 2] = Legend(figure, [blackl, whitel], [&quot;black&quot;, &quot;white&quot;], textsize = 12)
figure</code></pre><h2 id="Time-dependent-dynamics"><a class="docs-heading-anchor" href="#Time-dependent-dynamics">Time dependent dynamics</a><a id="Time-dependent-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-dynamics" title="Permalink"></a></h2><p>To use the time-dependent dynamics we simply use the keyword <code>scenario = :ramp</code> during model creation. However, we also want to see how the planet surface temperature changes and would be nice to plot solar luminosity as well. Thus, we define in addition</p><pre><code class="language-julia hljs">temperature(model) = mean(model.temperature)
mdata = [temperature, :solar_luminosity]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 temperature (generic function with 1 method)
 :solar_luminosity</code></pre><p>And we run (and plot) everything</p><pre><code class="language- hljs">model = daisyworld(solar_luminosity = 1.0, scenario = :ramp)
agent_df, model_df =
    run!(model, agent_step!, model_step!, 1000; adata = adata, mdata = mdata)

figure = CairoMakie.Figure(resolution = (600, 600))
ax1 = figure[1, 1] = Axis(figure, ylabel = &quot;daisy count&quot;, textsize = 12)
blackl = lines!(ax1, agent_df[!, :step], agent_df[!, :count_black], color = :red)
whitel = lines!(ax1, agent_df[!, :step], agent_df[!, :count_white], color = :blue)
figure[1, 2] = Legend(figure, [blackl, whitel], [&quot;black&quot;, &quot;white&quot;], textsize = 12)

ax2 = figure[2, 1] = Axis(figure, ylabel = &quot;temperature&quot;, textsize = 12)
ax3 = figure[3, 1] = Axis(figure, xlabel = &quot;tick&quot;, ylabel = &quot;L&quot;, textsize = 12)
lines!(ax2, model_df[!, :step], model_df[!, :temperature], color = :red)
lines!(ax3, model_df[!, :step], model_df[!, :solar_luminosity], color = :red)
for ax in (ax1, ax2); ax.xticklabelsvisible = false; end
figure</code></pre><h2 id="Interactive-scientific-research"><a class="docs-heading-anchor" href="#Interactive-scientific-research">Interactive scientific research</a><a id="Interactive-scientific-research-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-scientific-research" title="Permalink"></a></h2><p>Julia is an interactive language, and thus everything that you do with Agents.jl can be considered interactive. However, we can do even better by using our interactive application. In this example, rather than describing what solar forcing we want to investigate before hand, we use the interactive application, to control by ourselves, in real time, how much solar forcing is delivered to daisyworld.</p><p>So, let&#39;s make an <a href="examples/@ref"><code>InteractiveDynamics.abm_data_exploration</code></a>.</p><pre><code class="language-julia hljs">using InteractiveDynamics, GLMakie, Random</code></pre><pre><code class="language- hljs">model = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)</code></pre><p>The only significant addition to use the interactive application is that we make a parameter container for surface albedo and for the rate of change of solar luminosity, and add some labels for clarity.</p><pre><code class="language-julia hljs">params = Dict(
    :surface_albedo =&gt; 0:0.01:1,
    :solar_change =&gt; -0.1:0.01:0.1,
)
alabels = [&quot;black&quot;, &quot;white&quot;]
mlabels = [&quot;T&quot;, &quot;L&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;T&quot;
 &quot;L&quot;</code></pre><p>And we run it</p><pre><code class="language-julia hljs">fig, adf, mdf = abm_data_exploration(
    model, agent_step!, model_step!, params;
    mdata, adata, alabels, mlabels, plotkwargs...
)</code></pre><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../game_of_life_2D_CA/">« Conway&#39;s game of life</a><a class="docs-footer-nextpage" href="../forest_fire/">Forest fire »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 28 December 2021 20:25">Tuesday 28 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
